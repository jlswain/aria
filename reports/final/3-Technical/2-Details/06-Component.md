### System Components {#sec-3-2-6-1}

The objective of this section is to present technical details about the implementation of the 
proposed solution. The section begins by introducing some of the fundamental concepts used throughout
this project. Following these definitions is a component diagram showing the relationships between 
system components, as well as a description of each component and the interfaces that it provides. 
This section also includes a discussion of the architectural patterns that have been used, as well
as the deployment of the system.

#### Domain Concept Definitions {-}

Event: An Event is an object that drives changes within the system. Events are generated 
asynchronously from several sources, including:

- Smart Devices
- User Interface
- Machine Learning Component

Several subtypes of events have been identified:
    - User Command: An action on the user interface may generate an event that requires a change in the 
    state of the system or a smart device.
    - Sensor Value Change: A smart device that contains a sensor may generate an event to indicate that 
    its value has changed. 
    - Device Discovery: Upon detection of a new device in the home, the system generates an event.
    - Device Control: Device control events may be generated by either the User Interface or the 
    Machine Learning Component.

#### Component Organization {-}

![][system-components]

#### Component Descriptions {-}

##### Exchange Server {-}

As described in the Domain Concept Definitions, changes in the system are driven by events. Events 
may trigger updates to the user interface, changes to the state of smart devices, and machine 
learning decisions, among other actions. No single component contains the logic necessary to 
respond to every type of event. Additionally, some events may require a response from multiple 
components. 

One solution to this problem is to allow every component to communicate with every other component. 
This is undesireable because it would lead to high coupling between components, reducing the 
modifiability of the system.

In order to avoid this high coupling between components, every component that must react to system
events registers itself with a central Exchange Server component. Components send messages to
the Exchange Serer, rather than directly to other components, and the Exchange Server 
forwards these messages to the appropriate destination.

The Exchange Server component provides two interfaces: InternalMessaging and IPCMessaging. The 
InternalMessaging interface provides a way for components that are running in the same process as
the Exchange Server to send and receive event messages. The IPCMessaging interface allows
components that are running in different processes to send and receive messages from one another,
using an IPC (InterProcess Communication) protocol. The IPC protocol is described in further detail
in section [Appendix J-1](#J-1). Details about individual implementing this component can be 
found in [Appendix H-1](#H-1).

##### Event Logger {-}

The event logger listens to all event messages and transforming them into the appropriate format
to be stored in the database. This data will be accessible by the remote client as well as the 
machine learning algorithm. The event logger consumes the InternalMessaging interface provided by
the Exchange Server, which allows it to receive all event messages and record them. The
selection and design of persistent storage is discussed in [Appendix H-2](#H-2).

##### Machine Learning{-}

This component is responsible for the system's autonomous control of devices. Based on the 
historical data recorded byu the Event Logger, this component constructs a model of how the user 
expects their devices to behave.

This component uses the InternalMessaging interface provided by the Exchange Server to 
observe the current state of devices in the system. Based on these observations, this component can
generate device control messages to change the state of devices.

##### HTTP Gateway {-}

The HTTP gateway is responsible for providing access to system data and business objects to a 
web client. 

In addition to serving static HTML content, the HTTP gateway provides a RESTful API which supports
AJAX requests from the web client. The basic functionality of the gateway is to marshal HTTP 
requests from the web client into messages that other components can respond to. The responses to
these messages are then serialized into the JSON format that is usable by the web client.

The HTTP gateway also provides push event functionality. Some system events that are of interest to
the user interface may not be generated in response to an HTTP request from the web client. In 
order to propagate these events to the user interface, the HTTP Gateway maintains a Websocket 
connection with the web client. Further details about the implementation of the HTTP Gateway 
can be found in [Appendix H-7](#H-7).

##### Device Adapter {-}

Each smart device connected to the system communicates with the system hub and other devices using
a device-specific protocol. Sensor events received using the device-specific protocol must be 
translated into a format that can be used by other system components. Device control messages from 
the system must also be translated into the device-specific protocol. The Device Adapter is 
responsible for this translation functionality; it adapts the device specific protocol used by 
devices to the uniform messaging interface used internally by the system.

For technical specification about the Z-Wave protocol supported by the system, please see
[Appendix H-8](#H-8).

#### Architectural Patterns {-}

This section discusses the architectural patterns that have been identified within the system. Each
pattern is described by first presenting the problem that each pattern is intended to solve, in the 
context of this system.

##### Layer Pattern {-}

In order to allow for development on different parts of the code to proceed independently, it was
necessary to introduce separation of concerns into the organization of components. This project 
makes use of the layer pattern to improve separation of concerns.

The components of this project are paritioned into three layers: Persistence, Application, and 
Presentation. This pattern is commonly known as a three-tier architecture for client-server 
applications.

The persistence layer is responsible for storing objects in a database. In the Aria system, the 
persisted objects are events and device metadata.

The application layer is responsible for carrying out the business logic of the application. In the 
Aria system, this includes autonomous control of devices using machine learning.

The presentation layer is responsible for displaying information to the user, and providing the 
user with a way to control the system. In the Aria system, this layer is composed of HTML pages 
which make use of AJAX to retrieve data from the RESTful interface provided by the application 
layer.

The following diagram shows the organization of system components into a layered pattern.

![][layer-architecture]


##### Client-Server and Broker Patterns {-}

The decision to provide a user interface in the form of a web application imposed a client-server
architecture on the project. Client-server is the architecture used by the web, so some form of 
client-server architecture is necessary in the project. The deployment diagram below shows the 
process distribution between client and server.

![][client-server-deployment]

One architectural feature of note is the separation of the HTTP gateway component into a separate 
process from the application server. This design decision was made in order to improve the future 
usability of the system. An alternative solution considered during system design is to include both
the application logic and HTTP server within a single process. The decision to separate the 
components into two processes was made following a comparison of the benefits of each approach:

###### Single Process Benefits {-}

- Lower Overhead: Separation of a component into a separate process introduces overhead in 
    communication between components

- Ease of Implementation: Interprocess communication can potentially introduce unnecessary
    complexity to the code.

###### Multi-Process Benefits{-}

- Independence between the location of the HTTP server and the application logic. The web client
    does not need to know the location of the application server. 

- Allows use of different technologies for the HTTP server and application logic.

The independence between the location of the HTTP server and application logic is ultimately the
reason for separating the components into different processes. A common feature of existing smart 
home automation systems is the ability to control and monitor the home from a computer that is not c
urrently inside the home. For example; a user can see whether  their door is open or not from their
work computer. Users expect this feature to be available from any commercial home automation system.
While this is not currently a feature of the Aria system, the system design accounts for the fact 
that this is likely an essential feature in the future.

The ability to control the home remotely presents a technical challenge. In order for a web client
that is not on the same LAN as the hub device to communicate with the hub directly, the user would
need to configure port-forwarding on their router, modify their firewall configuration to allow for
inbound HTTP requests, and configure a public, static IP address for their network. For even a 
technical user this could be a daunting task. Given that the major requirement for the Aria system
is usability, direct communication between a remote client and the user's Aria hub is clearly not 
an acceptable solution.

An acceptable solution to this problem is to make use of a Broker pattern, with the HTTP server 
acting as a broker for the application server. The web client can communicates with the HTTP server 
at a well-known public address, potentially hosted on a cloud computing platform, from any physical 
location. This server can then relay requests to the Aria hub within the user's home.
The communication between the HTTP server and the system hub can use a mechanism that does 
not require special network configuration on the part of the user, such as WebSockets or 
HTTP long polling. 

The extensibility and usability benefits of separating the HTTP and application servers into 
separate processes are worth the added complexity and overhead. 