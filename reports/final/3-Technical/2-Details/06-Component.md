### System Components {#sec-3-2-6-1}

The objective of this section is to present technical details about the implementation of the 
proposed solution. The section begins by introducing some of the fundamental concepts used throughout
this project. Following these definitions is a component diagram showing the relationships between 
system components, as well as a description of each component and the interfaces that it provides. 
This section also includes a discussion of the architectural patterns that have been used, as well
as the deployment of the system.

#### Domain Concept Definitions {-}

Event: An Event is an object that drives changes within the system. Events are generated 
asynchronously from several sources, including:

- Smart Devices
- User Interface
- Machine Learning Component

Several subtypes of events have been identified:
    - User Command: An action on the user interface may generate an event that requires a change in the 
    state of the system or a smart device.
    - Sensor Value Change: A smart device that contains a sensor may generate an event to indicate that 
    its value has changed. 
    - Device Discovery: Upon detection of a new device in the home, the system generates an event.
    - Device Control: Device control events may be generated by either the User Interface or the 
    Machine Learning Component.

#### Component Organization {-}

![][system-components]

#### Component Descriptions {-}

##### Exchange Server {-}

As described in the Domain Concept Definitions, changes in the system are driven by events. Events 
may trigger updates to the user interface, changes to the state of smart devices, and machine 
learning decisions, among other actions. No single component contains the logic necessary to 
respond to every type of event. Additionally, some events may require a response from multiple 
components. 

One solution to this problem is to allow every component to communicate with every other component. 
This is undesireable because it would lead to high coupling between components, reducing the 
modifiability of the system.

In order to avoid this high coupling between components, every component that must react to system
events registers itself with a central Exchange Server component. Components send messages to
the Exchange Serer, rather than directly to other components, and the Exchange Server 
forwards these messages to the appropriate destination.

The Exchange Server component provides two interfaces: InternalMessaging and IPCMessaging. The 
InternalMessaging interface provides a way for components that are running in the same process as
the Exchange Server to send and receive event messages. The IPCMessaging interface allows
components that are running in different processes to send and receive messages from one another,
using an IPC (InterProcess Communication) protocol. The IPC protocol is described in further detail
in section [Appendix J-1](#J-1). Details about individual implementing this component can be 
found in [Appendix H-1](#H-1).

##### Event Logger {-}

The event logger listens to all event messages and transforming them into the appropriate format
to be stored in the database. This data will be accessible by the remote client as well as the 
machine learning algorithm. The event logger consumes the InternalMessaging interface provided by
the Exchange Server, which allows it to receive all event messages and record them. The
selection and design of persistent storage is discussed in [Appendix H-2](#H-2).

##### Machine Learning{-}

This component is responsible for the system's autonomous control of devices. Based on the 
historical data recorded byu the Event Logger, this component constructs a model of how the user 
expects their devices to behave.

This component uses the InternalMessaging interface provided by the Exchange Server to 
observe the current state of devices in the system. Based on these observations, this component can
generate device control messages to change the state of devices.

##### HTTP Gateway {-}

The HTTP gateway is responsible for providing access to system data and business objects to a 
web client. 

In addition to serving static HTML content, the HTTP gateway provides a RESTful API which supports
AJAX requests from the web client. The basic functionality of the gateway is to marshal HTTP 
requests from the web client into messages that other components can respond to. The responses to
these messages are then serialized into the JSON format that is usable by the web client.

The HTTP gateway also provides push event functionality. Some system events that are of interest to
the user interface may not be generated in response to an HTTP request from the web client. In 
order to propagate these events to the user interface, the HTTP Gateway maintains a Websocket 
connection with the web client. Further details about the implementation of the HTTP Gateway 
can be found in [Appendix H-7](#H-7).

##### Device Adapter {-}

Each smart device connected to the system communicates with the system hub and other devices using
a device-specific protocol. Sensor events received using the device-specific protocol must be 
translated into a format that can be used by other system components. Device control messages from 
the system must also be translated into the device-specific protocol. The Device Adapter is 
responsible for this translation functionality; it adapts the device specific protocol used by 
devices to the uniform messaging interface used internally by the system.

For technical specification about the Z-Wave protocol supported by the system, please see
[Appendix H-8](#H-8).

#### Architectural Patterns {-}

This section discusses the architectural patterns that have been identified within the system. Each
pattern is described by first presenting the problem that each pattern is intended to solve, in the 
context of this system.

##### Layer Pattern {-}

In order to allow for development on different parts of the code to proceed independently, it was
necessary to introduce separation of concerns into the organization of components. This project 
makes use of the layer pattern to improve separation of concerns.

The components of this project are paritioned into three layers: Persistence, Application, and 
Presentation. This pattern is commonly known as a three-tier architecture for client-server 
applications.

The persistence layer is responsible for storing objects in a database. In the Aria system, the 
persisted objects are events and device metadata.

The application layer is responsible for carrying out the business logic of the application. In the 
Aria system, this includes autonomous control of devices using machine learning.

The presentation layer is responsible for displaying information to the user, and providing the 
user with a way to control the system. In the Aria system, this layer is composed of HTML pages 
which make use of AJAX to retrieve data from the RESTful interface provided by the application 
layer.

The following diagram shows the organization of system components into a layered pattern.

![][layer-architecture]
